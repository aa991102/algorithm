문제 설명

OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진 아이언 슈트를 개발하여 판매하고 있습니다. 이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만, 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다. 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다. 단, 건전지 사용량을 줄이기 위해 점프로 이동하는 것은 최소로 하려고 합니다. 

​

아이언 슈트 구매자가 이동하려는 거리 N이 주어졌을 때, 

사용해야 하는 건전지 사용량의 최솟값을 return하는 solution 함수를 만들어 주세요.

​

예를 들어 거리가 5만큼 떨어져 있는 장소로 가려고 합니다.

아이언 슈트를 입고 거리가 5만큼 떨어져 있는 장소로 갈 수 있는 경우의 수는 여러 가지입니다.

  - 처음 위치 0 에서 5 칸을 앞으로 점프하면 바로 도착하지만, 건전지 사용량이 5 만큼 듭니다.

  - 처음 위치 0 에서 2 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 2) x 2에 해당하는 위치로 이동할 수 있으므로 위치 4

     로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 3 만큼 듭니다.

  - 처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2

     로 이동됩니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 2) x 2 만큼 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으

     로 점프하면 도착하므로 건전지 사용량이 2 만큼 듭니다.

위의 3가지 경우 거리가 5만큼 떨어져 있는 장소로 가기 위해서 3번째 경우가 건전지 사용량이 가장 적으므로 답은 2가 됩니다.

​

제한 사항

  - 숫자 N: 1 이상 10억 이하의 자연수

  - 숫자 K: 1 이상의 자연수

​

입출력 예

N

result

5

2

6

2

5000

5

입출력 예 설명

입출력 예 #1

위의 예시와 같습니다.

​

입출력 예 #2

처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동합니다. 이때 1 칸을 앞으로 점프하면 위치3으로 이동합니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 3) x 2 이동할 수 있으므로 위치 6에 도착합니다. 이 경우가 건전지 사용량이 가장 적으므로 2를 반환해주면 됩니다.

​

입출력 예 #3

위와 같은 방식으로 합니다.





다른사람풀이1

코딩테스트 연습 / Summer/Winter Coding(~2018) / 점프와 순간 이동 / 다른 사람의 풀이 / -

public class Solution {
    public int solution(int n) {
        int sub = 1;
        int ans = 0;
        while(n != 0){
            if(n % 2 == 1){
                n -= sub;
                ans += 1;
            }
            n /= 2;
        }
        return ans;
    }
}
​




다른사람풀이2

https://taesan94.tistory.com/142

public int solution(int n) {
    return Integer.bitCount(n);
}
이 분의 해석을 가져와봤다.

일단 텔레포트의 특성을 생각해보면, 이전까지의 이동거리*2를 텔레포트할 수 있다.

 

그렇다는 것은 주어진 거리N을 계속 2로 나누면 계속 텔레포트만 해서 이동할 수 있게 된다.

 

예를 들어 N=6이라고 하면

6/2 = 3 

3/2 = 1

이 된다. 6만큼의 거리를 이동하기 위해서 거리 3에서 텔레포트를 했고, 3만큼의 거리를 이동하기 위해서 거리 1에서 텔레포트를 했다.

그리고 거리 1은 최소 이동거리이기 때문에 1 이하의 거리는 계산해줄 필요가 없다. 

그런데 여기서 최초 거리 6의 이전 이동거리 3을 구했을 때는 나머지가 0이기 때문에 점프를 할 필요가 없었다.

그러나 3의 이동거리인 1을 구할 때는 나머지가 1이 생겼다. 그렇다는 것은 1만큼 점프를 더해주어야 한다.

즉, 3까지 이동하기 위해서는 거리 1에서 텔레포트! 해서 2로 이동한 후 + 1을 해주어야 한다.

 

위의 예시로 유추해보면 주어진 거리 N을 2로 나눌 때, 나머지가 0인 경우 1인 경우 2가지로 나뉘게 된다. 

0인 경우는 신경을 안 써도 되지만 1인 경우는 반드시 1만큼 점프를 해주어야 한다. ( 텔레포트를 하기 위해서! )

 

이렇게 마지막 예시인 5000을 2로 나누어가며 나머지를 찾던 도중.. 

아 이건 주어진 N을 2진수로 바꾸면 나머지가 1인 경우는 1로 표시되겠구나..라는 것을 캐치할 수 있었다.

 

그리고 Integer클래스에서 주어진 정수 n의 2진수 값에 해당하는 1의 개수를 반환해주는 Integer.bitcCount()를 활용하였다.

​

+) " N을 2진수로 바꾸면 나머지가 1인 경우는 1로 표시된다 " 에 대한 설명(게시글 댓글에서 가져옴)

만약 N=11일때 2진수 변환과정을보면

N = 11/2 = 5 가되고, 나머지가 1

N = 5/2 = 2 되고, 나머지가 1

N = 2/2 = 1 되고, 나머지가 0

N = 1/2 = 0 되고, 나머지가 1 종료.

​

따라서 2진수 1011(2)가 됩니다.

보시면 나머지가 1인경우 = 2진수1로표현입니다.

​

​

 
[프로그래머스] 점프와 순간 이동
문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/12980 

참조 출처
taesan94.tistory.com
