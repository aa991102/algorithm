문제 설명

* 효율성 테스트에 부분 점수가 있는 문제입니다.

​

평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 카카오 TV 라이브로 방송을 하기로 마음먹었다.


그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 독특한 방식을 생각해냈다.

​

회전판에 먹어야 할 N 개의 음식이 있다.

각 음식에는 1부터 N 까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다.

​

무지는 다음과 같은 방법으로 음식을 섭취한다.

 - 무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.

 - 마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.

 - 무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.

    - 다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.

 - 회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.

​

무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다.

무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다.

​

각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 

몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라.

​

제한사항

 - food_times 는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다.

 - k 는 방송이 중단된 시간을 나타낸다.

 - 만약 더 섭취해야 할 음식이 없다면 -1을 반환하면 된다.

​

정확성 테스트 제한 사항

 - food_times 의 길이는 1 이상 2,000 이하이다.

 - food_times 의 원소는 1 이상 1,000 이하의 자연수이다.

 - k는 1 이상 2,000,000 이하의 자연수이다.

​

효율성 테스트 제한 사항

 - food_times 의 길이는 1 이상 200,000 이하이다.

 - food_times 의 원소는 1 이상 100,000,000 이하의 자연수이다.

 - k는 1 이상 2 x 10^13 이하의 자연수이다.

​

입출력 예

food_times

k

result

[3, 1, 2]

5

1

입출력 예 설명

입출력 예1

 - 0~1초 동안에 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.

 - 1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.

 - 2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.

 - 3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.

 - 4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.

 - 5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 

   장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.






카카오 문제 풀이   2019 카카오 신입 공채 1차 코딩 테스트 문제 해설

​

이 문제를 완전히 해결하려면 효율성 테스트를 통과해야 합니다.

효율성 테스트의 제한 사항은 정확성 테스트보다 까다롭기 때문에 정확성 테스트를 통과한 풀이를 그대로 적용하면 시간 초과가 발생합니다. 따라서, 실행 시간을 줄일 수 있는 아이디어가 필요합니다.

​

정확성 풀이

시간이 1초 지날 때마다 다음 먹을 음식을 반복문을 이용해 하나하나 찾아가며 시뮬레이션하면 됩니다.

​

효율성 풀이

먼저 음식별 필요 시간을 오름차순으로 정렬합니다. 

시간의 오름차순으로 정렬해두면 음식을 먹는 데 소요되는 시간을 한꺼번에 지울 수 있습니다. 

예를 들어 정렬한 시간이 T = [1, 3, 3, 4, 5]라면 처음에 T[0] * 5 = 5만큼의 시간을 한꺼번에 지울 수 있습니다. 

다음으로 T[1]부터 남은 시간을 한꺼번에 제거합니다. 즉, (T[1] – T[0]) * 4 = 8 만큼의 시간을 한꺼번에 지웁니다. 

마찬가지로 (T[2] – T[1]) * 3 = 0 만큼의 시간을 한꺼번에 지울 수 있습니다.

위와 같은 방법으로 시간을 지워가다가, 지운 시간의 합이 K 보다 커지게 되면 남은 시간의 개수로 나눈 나머지를 이용해 K 초 후 다시 먹기 시작해야 될 음식의 번호를 바로 구할 수 있습니다. 이때, 남은 시간을 다시 원래 음식의 번호 순서대로 재정렬해야 합니다.

꼭 이 방법이 아니라도 K에 도달하는 시점을 빠르게 구할 수만 있으면 실행 시간을 줄일 수 있습니다.

​

정확성 42.08% / 효율성 5.52%






다른사람풀이1

https://gh402.tistory.com/25




 
[프로그래머스] 무지의 먹방 라이브 - JAVA
[프로그래머스] 무지의 먹방 라이브 - JAVA 문제설명 문제풀이 방법 일단, Collection.sort를 사용해서 먹는 시간이 가장 빠른 순으로 정렬 while문을 통해 빠른시간 순서대로 값을 빼내서 그 크기만큼 곱해준다...

gh402.tistory.com

​

다른사람풀이2

https://iron-jin.tistory.com/entry/2019-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B4%EC%A7%80%EC%9D%98-%EB%A8%B9%EB%B0%A9-%EB%9D%BC%EC%9D%B4%EB%B8%8C-feat-Java

import java.util.*;

class Solution {
    //음식의 번호와 먹는데 걸리는 시간에 대한 클래스
    private static class Food {
        int idx;
        int time;

        public Food(int idx, int time) {
            this.idx	= idx;
            this.time	= time;
        }
    }

    public static int solution(int[] food_times, long k) {
        int len = food_times.length;

        ArrayList<Food> list = new ArrayList<>();//음식에 대한 정보를 저장할 리스트

        //음식에 대한 정보를 리스트에 저장
        for (int i = 0; i < food_times.length; i++) {
            list.add(new Food(i+1,food_times[i]));
        }

        //음식을 먹는데 걸리는 시간을 오름차순으로 정렬
        Collections.sort(list,new Comparator<Food>() {
            @Override
            public int compare(Food o1, Food o2) {
                return o1.time - o2.time;
            }
        });

        int prev = 0;//이전 음식의 시간
        int idx = 0;//음식 번호

        for (Food food : list) {
            long diff = food.time - prev;//이전 음식 시간과의 차이
            long spen = diff * len;//가장 적은 시간이 걸리는 음식을 기준으로 전체 음식을 먹는데 걸리는 시간

            if (k >= spen) {//k가 가장 적은 시간이 걸리는 음식을 다 먹는데 시간보다 클 때는
                k -= spen;// 그 시간만큼 k에서 빼주고,
                prev = food.time;//다음 음식 시간 체크를 위해 현재 음식의 시간을 저장
            } else {
                k %= len;//몇 번째 먹을 차례인지를 구해줌

                List<Food> sub = list.subList(idx, list.size());//아직 남은 음식들의 번호를 리스트로 재구성

                Collections.sort(sub, new Comparator<Food>() {//리스트를 음식 번호를 기준으로 오름차순 정렬
                    @Override
                    public int compare(Food o1, Food o2) {
                        return o1.idx - o2.idx;
                    }
                });

                return sub.get((int)k).idx;//리스트에서 k에 해당하는 음식 번호를 반환
            }

            idx++;//현재 가장 시간이 적은 음식을 다 먹었기 때문에 다음 음식의 번호를 가리킨다.
            len--;//한 종류의 음식을 다먹었기 때문에 길이를 감소
        }

        return -1;//음식을 다 먹었다면, -1을 반환
    }
}
문제 접근 방법

 - 음식의 시간이 가장 적은 순으로 저장하고, 정렬한다.

 - 시간이 가장 적은 음식부터 다 먹는데 걸리는 시간이 k보다 작으면

 - k에서 그 시간만큼 빼주고, 다음 음식의 시간에서 현재 음식 시간만큼 빼준다.

 - k보다 클거나 같을 때는 해당 음식 시간 내에 다 먹지 못한다는 의미이므로,

 - 남은 음식의 길이로 k를 나눠주어 몇 번째 먹을 차례인지 구해주고,

 - 현재 남은 음식들 중에 몇 번째 먹을 차례인지 구해준다.

​

 
2019 카카오 블라인드 코딩테스트 - 무지의 먹방 라이브 (feat. Java)
문제 정보는 아래 링크를 확인해주세요! [무지의 먹방 라이브] 코딩테스트 연습 - 무지의 먹방 라이브 programmers.co.kr 문제 접근 방법 음식의 시간이 가장 적은 순으로 저장하고, 정렬한다. 시간이 가장 적은..

iron-jin.tistory.com
