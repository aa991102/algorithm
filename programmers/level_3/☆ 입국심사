문제 설명

n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.

처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 

가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 

하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

​

모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 

모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

​

제한사항

  - 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.

  - 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.

  - 심사관은 1명 이상 100,000명 이하입니다.

​

입출력 예

n

times

return

6

[7, 10]

28

입출력 예 설명

가장 첫 두 사람은 바로 심사를 받으러 갑니다.

7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.

10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.

14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.

20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.





===================================================
이진 탐색 = 이분 탐색 (Binary Search)


정렬된 배열 또는 리스트에 적합한 고속 탐색 방법이다.

배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내어 탐색의 범위를 반으로 줄인다.
찾고자 하는 값이 속해있지 않은 부분은 전혀 고려할 필요가 없기 때문에, 매 단계에서 검색해야 할 리스트의 크기를 반으로 줄일 수 있다.

이러한 방법을 반복적으로 사용해 탐색하는 방법이 이진 탐색이다.
데이터의 삽입이나 삭제가 빈번할 시에는 적합하지 않고, 주로 고정된 데이터에 대한 탐색에 적합하다.

ex 1) 10억 명이 정렬된 배열에서 이진 탐색을 이용해 특정 이름을 찾는다면 단 30번의 비교만으로 검색이 완료된다.
반면에 순차 탐색의 경우 평균 5억 번의 비교가 있어야 된다.

ex 2) 영어 사전에서 단어를 찾는 과정 역시 이진 탐색과 동일하다.
영어 사전을 펼쳐서 찾고자 하는 단어가 현재 페이지에 있는 단어보다 앞에 있는지, 뒤에 있는지를 결정한 다음,
단어가 있는 부분 만을 다시 검색한다.

 

이진 탐색의 구현

1. 탐색의 대상이 되는 자료들이 array[low] 에서부터 array[high]에 들어있다고 가정하자. 
   (정렬되어 있어야 함)
 즉 어떤 시점에서 탐색되어야 할 범위는 low에서 high 까지가 된다.
 맨 처음 low에는 0번 인덱스의 값, high에는 n-1번 인덱스의 값이 들어갈 것이다.

2. low와 high값에 의거해  중간값 mid 값은 (low + high) / 2이다.
 즉, array[low] ~ array[high] 까지의 탐색은
 array[low] ~ array[middle-1] +  array[middle+1] + array[high]까지의 탐색이 된다.

3. array[mid] 값과 구하고자 하는 key값을 비교한다.
 3-1. key > mid :  구하고자 하는 값이 중간값보다 높다면 low를 mid +1로 만들어 줌 (왼쪽 반을 버림)
 3-2. key < mid : 구하고자하는 값이 중간값 보다 낮다면 high를 mid-1로 만들어 줌 (오른쪽 반을 버림)
 3-3. key == mid : 구하고자 하는 값을 찾음 중간값 리턴 

4. low > high가 될 때까지 1~3번을 반복하면서 구하고자 하는 값을 찾는다.
 (이때까지 못 찾으면 탐색 실패 -1, false, error 등 return)

 

이진탐색 = 이분탐색 (Binary Search) - Java로 구현
이진 탐색 = 이분 탐색 (Binary Search) 정렬된 배열 또는 리스트에 적합한 고속 탐색 방법이다. 배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내어 탐색의..
minhamina.tistory.com





다른사람풀이

https://changyeon2.tistory.com/20

class Solution {
    public long solution(int n, int[] times) {
        long min = Long.MAX_VALUE;

        // 가장 짧은 심사시간 찾기
        for(int time : times){
            if(time < min) min = time;
        }

        // 시간의 최소값 = 심사시간이 가장 짧은 심사위원이 "한 번" 일하는 경우
        // 시간의 최대값 = 심사시간이 가장 짧은 심사위원"만" 일하는 경우 
        long max = n * min;
        long answer = 0;
        
        while(min <= max){
            long mid = (min + max) / 2; // 시간의 중간값
            long cnt = 0; // 처리한 인원
            
            for(int time : times){
                cnt += mid/time;

                // long 데이터값을 계속 더하다보면 long 범위를 초과할 수 있기 때문에 for문 안에서 확인
                if(cnt >= n){ // if문 안에서 answer값을 변경하기 때문에 cnt==n인 경우도 포함한다
                    answer = mid;
                    max = mid - 1; // 더 짧게 걸리는 시간이 있는지 체크하기 위해
                    break;
                }
            }
            
            if(cnt < n) min = mid + 1;
        }
        
        return answer;
    }
}
 




[Programmers] 입국심사 Solution (C++)
문제 원문 링크 : https://programmers.co.kr/learn/courses/30/lessons/43238 코딩테스트 연습 - 입국심사 n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸..
changyeon2.tistory.com

​
