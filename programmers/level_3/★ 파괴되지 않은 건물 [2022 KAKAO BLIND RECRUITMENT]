문제 설명
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

N x M 크기의 행렬 모양의 게임 맵이 있습니다. 
이 맵에는 내구도를 가진 건물이 각 칸마다 하나씩 있습니다. 
적은 이 건물들을 공격하여 파괴하려고 합니다. 
건물은 적의 공격을 받으면 내구도가 감소하고 내구도가 0이하가 되면 파괴됩니다. 
반대로, 아군은 회복 스킬을 사용하여 건물들의 내구도를 높이려고 합니다.

적의 공격과 아군의 회복 스킬은 항상 직사각형 모양입니다.
예를 들어, 아래 사진은 크기가 4 x 5인 맵에 내구도가 5인 건물들이 있는 상태입니다.

04_2022_공채문제_파괴되지않은건물_01.png

첫 번째로 적이 맵의 (0,0)부터 (3,4)까지 공격하여 4만큼 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.

04_2022_공채문제_파괴되지않은건물_02.png

두 번째로 적이 맵의 (2,0)부터 (2,3)까지 공격하여 2만큼 건물의 내구도를 낮추면 아래와 같이 4개의 건물이 파괴되는 상태가 됩니다.

04_2022_공채문제_파괴되지않은건물_03.png

세 번째로 아군이 맵의 (1,0)부터 (3,1)까지 회복하여 2만큼 건물의 내구도를 높이면 아래와 같이 2개의 건물이 파괴되었다가 복구되고 2개의 건물만 파괴되어있는 상태가 됩니다.

04_2022_공채문제_파괴되지않은건물_04.png

마지막으로 적이 맵의 (0,1)부터 (3,3)까지 공격하여 1만큼 건물의 내구도를 낮추면 아래와 같이 8개의 건물이 더 파괴되어 총 10개의 건물이 파괴된 상태가 됩니다. (내구도가 0 이하가 된 이미 파괴된 건물도, 공격을 받으면 계속해서 내구도가 하락하는 것에 유의해주세요.)

04_2022_공채문제_파괴되지않은건물_05.png

최종적으로 총 10개의 건물이 파괴되지 않았습니다.


건물의 내구도를 나타내는 2차원 정수 배열 board와 적의 공격 혹은 아군의 회복 스킬을 나타내는 2차원 정수 배열 skill이 매개변수로 주어집니다. 
적의 공격 혹은 아군의 회복 스킬이 모두 끝난 뒤 파괴되지 않은 건물의 개수를 return하는 solution함수를 완성해 주세요.


제한사항
  1 ≤ board의 행의 길이 (= N) ≤ 1,000
  1 ≤ board의 열의 길이 (= M) ≤ 1,000
  1 ≤ board의 원소 (각 건물의 내구도) ≤ 1,000
  1 ≤ skill의 행의 길이 ≤ 250,000
  skill의 열의 길이 = 6
  skill의 각 행은 [type, r1, c1, r2, c2, degree]형태를 가지고 있습니다.
  type은 1 혹은 2입니다.
    type이 1일 경우는 적의 공격을 의미합니다. 건물의 내구도를 낮춥니다.
    type이 2일 경우는 아군의 회복 스킬을 의미합니다. 건물의 내구도를 높입니다.
  (r1, c1)부터 (r2, c2)까지 직사각형 모양의 범위 안에 있는 건물의 내구도를 degree 만큼 낮추거나 높인다는 뜻입니다.
    0 ≤ r1 ≤ r2 < board의 행의 길이
    0 ≤ c1 ≤ c2 < board의 열의 길이
    1 ≤ degree ≤ 500
    type이 1이면 degree만큼 건물의 내구도를 낮춥니다.
    type이 2이면 degree만큼 건물의 내구도를 높입니다.
  건물은 파괴되었다가 회복 스킬을 받아 내구도가 1이상이 되면 파괴되지 않은 상태가 됩니다. 즉, 최종적으로 건물의 내구도가 1이상이면 파괴되지 않은 건물입니다.

정확성 테스트 케이스 제한 사항
  1 ≤ board의 행의 길이 (= N) ≤ 100
  1 ≤ board의 열의 길이 (= M) ≤ 100
  1 ≤ board의 원소 (각 건물의 내구도) ≤ 100
  1 ≤ skill의 행의 길이 ≤ 100
  1 ≤ degree ≤ 100

효율성 테스트 케이스 제한 사항
  주어진 조건 외 추가 제한사항 없습니다.

입출력 예
  board	                                              skill	                                                      result
  [[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5]]	  [[1,0,0,3,4,4],[1,2,0,2,3,2],[2,1,0,3,1,2],[1,0,1,3,3,1]]	  10
  [[1,2,3],[4,5,6],[7,8,9]]	                          [[1,1,1,2,2,4],[1,0,0,1,1,2],[2,2,0,2,0,100]]	               6

입출력 예 설명
입출력 예 #1
  문제 예시와 같습니다.

입출력 예 #2
  <초기 맵 상태>

  04_2022_공채문제_파괴되지않은건물_06.png

  첫 번째로 적이 맵의 (1,1)부터 (2,2)까지 공격하여 4만큼 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.

  04_2022_공채문제_파괴되지않은건물_07.png

  두 번째로 적이 맵의 (0,0)부터 (1,1)까지 공격하여 2만큼 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.

  04_2022_공채문제_파괴되지않은건물_08.png

  마지막으로 아군이 맵의 (2,0)부터 (2,0)까지 회복하여 100만큼 건물의 내구도를 높이면 아래와 같은 상황이 됩니다.

  04_2022_공채문제_파괴되지않은건물_09.png

  총, 6개의 건물이 파괴되지 않았습니다. 따라서 6을 return 해야 합니다.

제한시간 안내
  정확성 테스트 : 10초
  효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수

===================================================================================================================================================
<카카오 문제해설> https://tech.kakao.com/2022/01/14/2022-kakao-recruitment-round-1/

이 문제는 2차원 배열에서 구간의 변화를 어떻게 효율적으로 처리할지가 관건인 문제입니다. 가장 쉽게 생각할 수 있는 브루트 포스로 풀 경우 정확성 테스트 케이스는 모두 맞출 수 있지만, 시간 복잡도가 O(N * M * K)가 되어 효율성 테스트케이스에서 시간 초과가 발생하게 됩니다.

2차원 배열에 대한 구간의 변화를 처리하는 방법을 설명드리기 전에, 우선 1차원 배열을 효율적으로 처리할 수 있는 방법을 설명드리겠습니다.

예를 들어, [1,2,4,8,9]의 배열이 있고, 0번째부터 3번째 원소까지 2만큼 빼야 하는 상황이라고 가정하겠습니다. 즉, 배열을 [-1,0,2,6,9]로 만들고 싶은 상황입니다. 가장 쉬운 방법으로는 0번째부터 3번째 원소까지 반복문을 사용해 2만큼 빼주는 방법이 있지만, 이 방법은 O(M)의 시간 복잡도가 걸립니다.

O(M)의 시간 복잡도를 O(1)로 만들 수 있는 방법은 바로 누적합을 이용하는 방법입니다. 위의 예시의 경우 [-2,0,0,0,2]를 저장한 새로운 배열을 생성합니다. 이 배열을 앞에서부터 누적합하면 [-2,-2,-2,-2,0]이 되기 때문에 초기 배열인 [1,2,4,8,9]과 더해주면 [-1,0,2,6,9]를 얻을 수 있게 됩니다. 즉, 1차원 배열의 a번째 원소부터 b번째 원소까지 c만큼의 변화를 주겠다고 하면 새로운 배열의 a번째 원소에 c를 더하고 b+1번째 원소에 c를 빼면 됩니다.

이 방식으로 문제를 풀면 O(N * M * K)의 복잡도를 O(N * K)로 줄일 수 있지만, 이 또한 시간 초과가 발생합니다.

따라서 이 아이디어를 2차원 배열로 확장해 줘야 합니다. 이번엔 2차원 배열에서 (0,0)부터 (2,2)까지 n만큼 변화시키는 경우를 예로 들어보겠습니다.

배열의 행만 따로 봐서 위에서 설명한 아이디어를 하나의 행씩 적용시키면, 1차원 배열의 0번째 원소부터 2번째 원소까지 n만큼의 변화를 3개의 행에 적용시키는 것이 됩니다.

    n 0 0 -n
    n 0 0 -n
    n 0 0 -n
위 행렬을 다시 열만 따로 보면, 가장 왼쪽 열의 0번째 원소부터 2번째 원소까지 n만큼의 변화와 가장 오른쪽 열의 0번째 원소부터 2번째 원소까지 -n만큼의 변화와 같습니다. 각 열에 위의 아이디어를 적용시키면 아래와 같습니다. 이런 식으로 2차원 배열에도 적용시킬 수가 있습니다.

    n 0 0 -n
    0 0 0 0
    0 0 0 0
    -n 0 0 n
즉, 2차원 배열에서 (x1,y1)부터 (x2,y2)까지 n만큼의 변화는 (x1,y1)에 +n, (x1,y2+1)에 -n, (x2+1,y1)에 -n, (x2+1,y2+1)에 +n을 한 것과 같습니다. 위 배열을 위에서 아래로 누적합한 뒤, 왼쪽에서 오른쪽으로 누적합하거나 왼쪽에서 오른쪽으로 누적합 한 뒤, 위에서 아래로 누적합하면 처음에 의도한 (0,0)부터 (2,2)까지 n만큼 변화시키는 배열이 나오는 것을 확인할 수 있습니다.

    n n n 0
    n n n 0
    n n n 0
    0 0 0 0
이러한 방법으로 skill의 한 원소를 O(1)만에 처리할 수 있다는 것을 알 수 있습니다. 따라서 위의 방법으로 K개의 skill을 모두 처리할 수 있는 배열을 만드는데 O(K)가 걸리게 됩니다. 그리고 해당 배열을 누적합 배열로 바꾸는 과정이 필요한데, 행과 열을 각각 누적합 해줘야 하기 때문에 O(N * M)가 걸리게 됩니다. 따라서 O(K + N * M)으로 문제를 해결할 수 있습니다.

이해를 돕기 위해 2번 테스트케이스를 예시로 추가 설명드리겠습니다.

1. (1,1)부터 (2,2)까지 -4만큼 변화를 줘야 합니다. (배열의 (1,1)과 (3,3)에 -4, 배열의 (1,3)과 (3,1)에 4만큼 변화를 줍니다.)

     0    0    0    0
     0   -4    0    4
     0    0    0    0
     0    4    0   -4
2. (0,0)부터 (1,1)까지 -2만큼 변화를 줘야 합니다. (배열의 (0,0)과 (2,2)에 -2, 배열의 (0,2)과 (2,0)에 2만큼 변화를 줍니다.)

    -2    0    2    0
     0   -4    0    4
     2    0   -2    0
     0    4    0   -4
3. (2,0)부터 (2,0)까지 +100의 변화를 줘야 합니다. (배열의 (2,0)과 (3,1)에 100, 배열의 (2,1)과 (3,0)에 -100만큼 변화를 줍니다.)

    -2    0    2    0
     0   -4    0    4
    102  -100 -2    0
   -100   104  0   -4
이 배열을 이제 위에서 아래로 누적합 해주겠습니다.

    -2    0    2    0
    -2   -4    2    4
    100  -104  0    4
     0    0    0    0
그다음 왼쪽에서 오른쪽으로 누적합 해주겠습니다.

    -2   -2    0    0
    -2   -6   -4    0
    100  -4   -4    0
     0    0    0    0
이 배열을 board와 합쳐 주겠습니다.

    1 2 3         -2  -2   0        -1  0  3
    4 5 6    +    -2  -6  -4    =    2 -1  2
    7 8 9         100 -4  -4        107 4  5
마지막 결과 배열과 같은 배열이 나왔습니다. 이 배열에서 0보다 큰 정수의 개수를 구하면 됩니다.

===================================================================================================================================================
내 풀이 <정확성 성공, 효율성 실패>

class Solution {
    public int solution(int[][] board, int[][] skill) {
        int answer = 0;
        
        for (int i=0; i<skill.length; i++) {
            int val = skill[i][5] * (skill[i][0] == 1 ? -1 : 1);
            
            for(int j=skill[i][1]; j<=skill[i][3]; j++) {
                for(int k=skill[i][2]; k<=skill[i][4]; k++) {
                    board[j][k] += val;
                }
            }
        }
        
        for (int i=0; i<board.length; i++) {
            for (int j=0; j<board[i].length; j++) {
                if(board[i][j] > 0) answer++;
            }
        }
        
        return answer;
    }
}
===================================================================================================================================================

참조 https://programmers.co.kr/questions/25471
